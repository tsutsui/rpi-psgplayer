# rpi-psgplayer

Raspberry Pi の GPIO で **YAMAHA YM2149F (AY-3-8910 互換)** を直結し、**PC-6001 用 PSG 音源ドライバ（よっしゅさん版 ver1.1c 相当）のコンパイル済み演奏データ**を再生する、最小構成の C 言語プレーヤーです。

関連リンク（雰囲気だけ伝える用）:

- Open Source Conference 2026 大阪 NetBSDセミナー発表資料: https://speakerdeck.com/tsutsui/osc2026osaka
- 演奏デモ動画: https://www.nicovideo.jp/watch/sm45903620 https://www.youtube.com/watch?v=3sXxpfP00mU

---

## これはなに？

「レトロ PC の音源チップを、現代の小さい OS（Raspberry Pi + NetBSD）で **“実デバイスのレジスタを叩いて鳴らす”**」ためのデモ用ソフトです。

- Raspberry Pi の GPIO を **8-bit パラレルバス**として使い、
- YM2149F の **BDIR/BC1** 制御で “アドレスラッチ → データ書き込み” を行い、
- 2ms 周期で PC-6001 ドライバ互換のインタープリタ（`psg_driver.c`）を呼び出し、
- レジスタ書き込みを YM2149F に流し込みます。

要するに:

> 「PC-6001 の曲データ（コンパイル済み）を PC-6001 で再生していたのとまったく同じシーケンスで、Raspberry Pi から YM2149F のレジスタに直接書いて同じ曲を鳴らすプレーヤー」

です。

---

## 想定環境

### OS

- 主対象: **NetBSD/evbarm**（Raspberry Pi）
- /dev/mem を `mmap(2)` して GPIO/Clock Manager に直接アクセスします（通常 root 権限が必要）

### NetBSD カーネルの前提（重要）

NetBSD/evbarm のデフォルトカーネルのままでは、2ms 周期の安定再生が難しいため、
**カーネルコンフィグを変更して再ビルドしたカーネルが必要**です。

- **2ms 再生のために HZ=1000 が必要**
  - NetBSD/evbarm のデフォルトは `HZ=100`（= 1 tick が 10ms）です。
  - このプレーヤーは 2ms 基準でドライバ互換処理を回すため、少なくとも `options HZ=1000` を推奨します。
- **/dev/mem の `mmap(2)` 制限回避のため `INSECURE` が必要**
  - GPIO 等へ直接アクセスするため `/dev/mem` を使います。
  - securelevel 制限を避けるため、`options INSECURE` を有効にしたカーネルが必要です。

例（KERNEL config の一部）:

```

options         HZ=1000
options         INSECURE

````

※この README では kernel config の作り方（`config(1)` / `build.sh kernel=...` 等）の手順は省略します。  
※上記 2 点は「このプレーヤーを NetBSD/evbarm 上で動かす」という目的に対しての前提条件です。

---

## 必要なもの（ハードウェア）

- Raspberry Pi（GPIO と Clock Manager を持つ世代）
- YM2149F（または AY-3-8910 互換）
- **レベル変換やバスの電気的整合を取るための I/F 回路**（重要）
  - Raspberry Pi は 3.3V GPIO です
  - チップ側の電圧/しきい値/負荷を考慮して、自己責任で安全に接続してください

---

## 構成（ソースの役割）

- `psg_play.c`  
  メイン。ファイルロード、バックエンド初期化、2ms ループ、UI 呼び出し。
- `p6psg.c / p6psg.h`  
  PC-6001 ドライバ用の **演奏データバイナリ**を読み込んで ch ごとに分割。
- `psg_driver.c / psg_driver.h`  
  PC-6001 PSG 音源ドライバ互換の **インタープリタ**。2ms tick で状態更新して AY レジスタに書く。
- `psg_backend_rpi_gpio.c / psg_backend_rpi_gpio.h`  
  Raspberry Pi GPIO + Clock Manager を使って YM2149F を叩く実装（/dev/mem を使用）。
- `player_ui.c / player_ui.h`  
  テキスト UI（デモ画面）。固定テンプレに対して差分描画します。

設計方針:

- PSG I/O はバックエンドで抽象化（将来差し替え可能な形）
- 互換ドライバ（`psg_driver`）は I/O と分離（UI と実機 I/O を同時に回すため）

---

## ビルド

`configure` などの自動設定は未サポートです。

```sh
make
````

---

## 使い方

```sh
sudo ./psg_play [-t title] p6psgfile.bin
```

* `p6psgfile.bin` は **PC-6001 PSG ドライバ用のコンパイル済み演奏データ**を想定しています
* タイトルは UI 表示用です（省略時は `"OSC demo"` など）

終了:

* `q` または `Q`
* `Ctrl+C`
* 画面再描画: `Ctrl+L`

---

## 入力データ（p6psg 形式）

このプレーヤーが読むデータは「先頭に 3ch の先頭アドレスが入っていて、その後に 3ch のデータが続く」形式です。

`p6psgmmlc` で生成できる形式と同じ想定です:

* p6psgmmlc: [https://github.com/tsutsui/p6psgmmlc](https://github.com/tsutsui/p6psgmmlc)

### ざっくりフォーマット

先頭 8 バイト + データ:

* +0: ch A 先頭アドレス (little endian, word)
* +2: ch B 先頭アドレス (little endian, word)
* +4: ch C 先頭アドレス (little endian, word)
* +6: 予約（未使用）
* +8〜: 各チャンネルのデータ本体

各チャンネル末尾には `0xFF`（エンドマーク）が必要です。

---

## Raspberry Pi 側 GPIO 配線（V2 ボード）

この実装は **V2 配線**を前提にしています。

| 役割       |           GPIO | 備考             |
| -------- | -------------: | -------------- |
| DA0..DA7 | GPIO20..GPIO27 | LSB=GPIO20     |
| BDIR     |         GPIO12 | 制御線            |
| BC1      |         GPIO13 | 制御線            |
| RESET    |         GPIO17 | active-high （NPNトランジスタオープンコレクタ駆動） |
| CLOCK    |          GPIO4 | GPCLK0 (ALT0)  |

* BC2 は H 固定（回路側で固定）
* A8/A9 は固定（回路側で固定）という前提で、レジスタアクセス最小構成にしています

### 2MHz クロック出力について

`psg_backend_rpi_gpio.c` は Raspberry Pi の Clock Manager を使い、GPCLK0 を出力します。

* 基本: **2.000 MHz**
* 実験用: **1.9968 MHz**（PC-6001実機の周波数）

注意:

* 実装は「PLLD=500MHz と仮定」しています（機種によって異なる可能性あり）
* Pi 4 系などで PLLD 周波数が異なる場合は調整が必要かもしれません

---

## テキスト UI（`player_ui.c`）

`player_ui.c` は「OSC 展示デモ用」に作った、**固定 79 桁 × 23 行**の ANSI テキスト UI です。

```
+-----------------------------------------------------------------------------+
| YM2149 P6 PSG Player on Raspberry Pi 3B @ Open Source Conference Osaka 2026 |
| Clock: 2.000 MHz, Rate: 2ms/tick, BCM2837 GPIO controlled by NetBSD/evbarm  |
+-----------------------------------------------------------------------------+
| Music Title: Stay with me forever (from YS2)          bpm=156.3  t=    9.7s |
+-----------------------------------------------------------------------------+
| Ch A: NOTE=A4   440.1Hz  VOL=13 [###########--..]  TONE=ON   NOISE=OFF      |
| Ch B: NOTE=G#4  416.7Hz  VOL=12 [############...]  TONE=ON   NOISE=OFF      |
| Ch C: NOTE=NOI  ---.-Hz  VOL=14 [##############.]  TONE=OFF  NOISE=ON       |
+-+--------+-----------+-----------+-----------+-----------+-----------+------+
| |O1      |O2         |O3         |O4         |O5         |O6         |O7    |
|C|  # # # |# #  # # # |# #  # # # |# #  # # # |# #  # # # |# #  # # # |# #  #|
|h|<F G A BC D EF G A BC D EF G A BC D EF G A BC D EF G A BC D EF G A BC D EF>|
+-+--------+-----------+-----------+-----------+-----------+-----------+------+
|A|.........................................A.................................|
|B|........................................B..................................|
|C|...............................N...........................................|
+-----------------------------------------------------------------------------+
| Reg0 (Freq Fine A): 1Ch || Reg1 (Freq Rough A) : 01h || Reg8 (Level A): 0Bh |
| Reg2 (Freq Fine B): 2Ch || Reg3 (Freq Rough B) : 01h || Reg9 (Level B): 0Ch |
| Reg4 (Freq Fine C): B8h || Reg5 (Freq Rough C) : 03h || RegA (Level C): 0Eh |
| Reg6 (Freq Noise) : 14h || Reg7 (Mixer Setting): DCh ||                     |
+-----------------------------------------------------------------------------+
```

### 特徴

* 固定テンプレ（`ui_tmpl[]`）を **初回に 1 回だけ描画**し、その後は差分のみ更新

  * 1 フレームの更新も、内部バッファに溜めて **最後に `write(2)` 1 回**で出します
* タイトルは UTF-8 を想定

  * `setlocale(LC_CTYPE, "")` を呼び、`mbrtowc()` と `wcwidth()` で表示桁数に収まるよう整形します
  * 厳密な合成グリフ対応までは狙わず、「途中で切っても文字化けしない」「日本語が出せる」程度の実用狙いです
* 表示内容:

  * Ch A/B/C の NOTE / 周波数 / VOL / バー / TONE/NOISE
  * ピアノロール風のマーカー（発音イベントを 1 点プロット）
  * レジスタ 0..7 と 8..A の主要値（`xxh` 表示）
* 端末制御:

  * `termios` で非カノニカル + エコーオフ
  * カーソル非表示、autowrap 無効
  * alternate screen を使用
  * `genfb(4)+wsdisplay(4)` の見た目崩れを避けるため、カーソル位置を先に枠外へ退避

### “ノイズのみ” の扱い

TONE=OFF/NOISE=ON の場合、MML のノート表現が聴感と一致しないため:

* NOTE は `"NOI"` を表示
* ピアノロール位置は reg6（ノイズ周期）から **擬似的に散らす**方式を採用しています

---

## PC-6001 PSG ドライバ互換（実装メモ）

このプレーヤーの “キモ” は、`psg_driver.c` の互換インタープリタです。
解析と実装で特に手間がかかったポイントだけ軽く触れます。

### 2ms tick とテンポ

* ドライバは 2ms 基準で動作します
* `T` コマンド（t96）を「96 分音符 = 2ms * t96 回」として扱い、
* 内部では `tempo_counter` をカウントしてチャンネル処理を回します

UI 用に bpm も計算して表示しています（小数 1 桁）。

### タイ（&）とゲート（Q）

* 音符は「音長（len）」と「ゲートオフ位置（q）」を持ちます
* タイの場合はゲートオフしない（`q=0` 扱い）など、実機ドライバっぽい挙動に寄せています

### ネスト / ループ制御（`[` `]` `:`）

* `[` でネスト開始（最大 4 段）
* `]` で相対ジャンプ（1byte/2byte の差あり）
* `:` は単なるラベルではなく「最終ループだけ脱出」みたいな制御が絡みます

  * ここが “見た目より面倒” なところ

### ビブラート（`M`, `M%` など）

* `M` は複数パラメータを内部ワークに保持し、tick 毎に周波数補正（LFO）
* “タイ継続時にビブラート初期化するか” の挙動は互換性と見た目の兼ね合いで調整しています

  * 現状は `KEEP_VIBRATO_TIE` を使って寄せています

### ソフトウェア EG（`S`）

* PSG のハードウェア EG ではなく、ドライバ側の音量テーブル制御を 2 段で回す実装です
* 実装は “それっぽく鳴る” ことを優先して整理しています

### I コマンド（`F4`）

* `I` は「演奏同期用に値を外に出す」用途を想定
* この実装では `drv->main.i_command_value` に書き込み、取得 API を用意しています

  * いまのところプレーヤー本体では積極的に使っていません

---

## 既知の制限 / TODO

* Pi 世代差（PLLD 周波数など）の扱い整理
* NetBSD 以外のOSでの動作検討（/dev/mem 周りなど）
* UI の整理（デモ用途のため割り切りが多い）
* 未実装/簡略化しているコマンドの詰め

---

## ライセンス

2 条項 BSD ライセンス想定です。詳細は添付の [LICENSE](LICENSE) ファイルを参照してください。

---

## 免責事項

* 本リポジトリは「ハードを壊さない配線」を保証しません。
  GPIO 直結は危険になりがちなので、I/F 回路・電圧・負荷を十分確認の上、自己責任で利用してください。
* /dev/mem を叩くので、OS や機種によっては挙動が変わる可能性があります。
